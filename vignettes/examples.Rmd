---
title: "Latent Variable Multivariate Mixed-type Response Regression"
author: "Karl Oskar Ekvall"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Latent Variable Multivariate Mixed-type Response Regression}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Installation

The package can be installed from GitHub, using devtools.

```{r}
  # devtools::install_github("koekvall/lvmmrPQL") 
```


# Notation

The matrix of responses, $Y$, has $n$ rows and $r$ columns. The matrix of predictors, $X$, has $nr$ rows and $p$ columns; the first $r$ rows of $X$ are the design matrix for the $r$ responses in the first row of $Y$, the next $r$ rows of $X$ are the design matrix for the second row of $Y$, and so on. Thus, \texttt{matrix(X %*% Beta, nrow = n, ncol = r, byrow = TRUE)} gives an $n\times r$ matrix whose $i$th row is the mean of the $i$th latent vector.

# Example with normal responses
```{r}
set.seed(4)
n <- 100
type <- rep(1, 1) # Only normal responses
r <- length(type)

# Each observation has its own intercept
X <- Matrix::kronecker(rep(1, n), diag(r))
Beta_true <- (1:r) / r

# Variance parameters, psi treated as known
Sigma_true <- 0.5^abs(outer(1:r, 1:r, FUN = "-"))
psi_true <- rep(0.5, r)

Y <- lvmmrPQL::generate_lvmmr(X = X, Beta = Beta_true, R = chol(Sigma_true),
                    type = type, psi = psi_true)
# No restrictions with normal responses
M <- matrix(NA, r, r)

# Compute MLEs
fit_MLE <- lm(Y ~ 1)
Beta_MLE <- c(coef(fit_MLE))
Sigma_MLE <- crossprod(matrix(residuals(fit_MLE), ncol = r)) / n -
  diag(psi_true, r)

# Does MLE exist? That is, is maximizer PD?
min(eigen(Sigma_MLE)$values)

# Skip W update; obj. fun, does not depend on W with mult. norm. resp.
# MLE of Beta does not depend on Sigma, so expect correct MLE for Beta
# regardless of whether algorithm finds MLE of Sigma.
fit <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = T,
                           quiet = c(T, T, T, T),
                           maxit = c(100, 100, 500, 0),
                           tol = c(1e-12, 1e-8, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = FALSE)
# Difference to MLEs
fit$Beta - Beta_MLE
fit$Sigma - Sigma_MLE


# With MLE as starting value
fit <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = T,
                           quiet = c(F, T, T, T),
                           maxit = c(100, 100, 500, 0),
                           tol = c(1e-12, 1e-8, 1e-12, 1e-8),
                           pgd = FALSE,
                           Beta = Beta_MLE,
                           Sigma = Sigma_MLE,
                           psi = psi_true)
fit$iter
# Difference to MLEs
fit$Beta - Beta_MLE
fit$Sigma - Sigma_MLE

# See that objective is correct
D1 <- t(lvmmrPQL:::get_cumulant_diffs(t(fit$W), type, 1))
D2 <- t(lvmmrPQL:::get_cumulant_diffs(t(fit$W), type, 2))

lvmmrPQL:::working_ll_rcpp(Y_T = t(Y), X_T = t(X), beta = fit$Beta,
                                  Sigma = fit$Sigma, W_T = t(fit$W),
                                  psi = psi_true,
                                  D1_T = t(D1), D2_T = t(D2))

lvmmrPQL:::working_ll_rcpp(Y_T = t(Y), X_T = t(X), beta = Beta_MLE,
                                  Sigma = Sigma_MLE, W_T = t(fit$W),
                                  psi = psi_true,
                                  D1_T = t(D1), D2_T = t(D2))

# Double check w. multivariate normal likelihood
Xb <- matrix(X %*% fit$Beta, nrow = n, ncol = r, byrow = T)
sum(mvtnorm::dmvnorm(x = Y - Xb, sigma = fit$Sigma +
                       diag(psi_true, r), log = TRUE))
sum(mvtnorm::dmvnorm(x = Y - predict(fit_MLE), sigma = Sigma_MLE +
                       diag(psi_true, r), log = TRUE))


```


# Example with mixed-type responses
```{r}
set.seed(40)
n <- 50
type <- c(1, 2, 3)
r <- length(type)


# Each observation has an intercept and two uniform predictor (SUR)
p <- 2
X <- matrix(0, nrow= n * r, ncol = r * ( p + 1))
counter <- 1
for(jj in 1:n){
  for(kk in 1:r){
    X[counter, ((kk-1)*(p+1) + 1):(kk*(p+1))] <- c(1, runif(p, -1, 1))
    counter <- counter + 1
  }
}

Beta_true <- 1.5 * runif((p + 1) * r, -1, 1)

# Variance parameters, psi treated as known
Sigma_true <- matrix(0.999, r, r)
diag(Sigma_true) <- 1
Sigma_true <- 0.1 * Sigma_true
psi_true <- rep(1e-7, r)
psi_true[type == 2] <- 1 # Bernoulli does not support psi

Y <- lvmmrPQL::generate_lvmmr(X = X, Beta = Beta_true, R = chol(Sigma_true),
                    type = type, psi = psi_true)
# No restrictions with normal and Poisson responses
M <- matrix(NA, r, r)
diag(M)[type == 2] <- 1


fit_trust <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = FALSE,
                           quiet = c(F, T, T, T),
                           maxit = c(50, 100, 500, 100),
                           tol = c(1e-5, 1e-7, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = FALSE)
# Use starting values
fit_pgd <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = FALSE,
                           quiet = c(F, F, F, T),
                           maxit = c(50, 100, 500, 100),
                           tol = c(1e-5, 1e-7, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = TRUE,
                           Beta = fit_trust$Beta,
                           Sigma = fit_trust$Sigma,
                           W = fit_trust$W)

# Diagonal
M <- diag(NA, r)
diag(M)[type == 2] <- 1
fit_diag <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = FALSE,
                           quiet = c(F, T, T, T),
                           maxit = c(50, 100, 500, 100),
                           tol = c(1e-5, 1e-7, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = TRUE,
                           Beta = fit_trust$Beta,
                           Sigma = diag(diag(fit_trust$Sigma), r),
                           W = fit_trust$W)

# Create prediction data
n_pred <- 1e4
X_new <- matrix(0, nrow = n_pred * r, ncol= r * (p + 1))
counter <- 1
for(jj in 1:n_pred){
  for(kk in 1:r){
    X_new[counter, ((kk - 1) * (p + 1) + 1):(kk * (p + 1))] <-
      c(1, runif(p, -1, 1))
    counter <- counter + 1
  }
}
Y_new <- lvmmrPQL::generate_lvmmr(X = X_new, Beta = Beta_true, R = chol(Sigma_true),
                    type = type, psi = psi_true)

# Get GLM Fit
unique_types <- unique(type)
uni_coefs <- matrix(0, ncol = length(unique_types), nrow = r * (p + 1))
for(ii in 1:length(unique_types)){
  fam <- c("gaussian", "binomial", "quasipoisson")[unique_types[ii]]
  y_uni <- c(Y[, type == unique_types[ii]])
  X_uni <- X[rep(type == unique_types[ii], n), ]
  glm_fit <- stats::glm(y_uni ~ 0 + X_uni, family = fam)
  uni_coefs[, ii] <- stats::coef(glm_fit)
}
Beta_GLM <- apply(uni_coefs, 1, mean, na.rm = T)

Xb_GLM <- matrix(X_new %*% Beta_GLM, nrow = n_pred, ncol = r, byrow = T)
pred_GLM <- t(lvmmrPQL:::get_cumulant_diffs(t(Xb_GLM), type, 1))

# We win (sometimes and often small).
pred_trust <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = fit_trust$Beta,
                                          sigma = sqrt(diag(fit_trust$Sigma)),
                                          type = type,
                                          num_nodes = 15)
pred_pgd <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = fit_pgd$Beta,
                                          sigma = sqrt(diag(fit_pgd$Sigma)),
                                          type = type,
                                          num_nodes = 15)
pred_diag <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = fit_diag$Beta,
                                          sigma = sqrt(diag(fit_diag$Sigma)),
                                          type = type,
                                          num_nodes = 15)
pred_oracle <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = Beta_true,
                                          sigma = sqrt(diag(Sigma_true)),
                                          type = type,
                                          num_nodes = 15)

get_rmse <- function(x){sqrt(colMeans((x - Y_new)^2))}
RMSE <- rbind(get_rmse(pred_trust), get_rmse(pred_pgd), get_rmse(pred_diag), 
      get_rmse(pred_GLM))
RMSE <- t(t(RMSE) / get_rmse(pred_oracle))
rownames(RMSE) <- c("Trust", "PGD", "Indep.", "GLM")
RMSE
```

